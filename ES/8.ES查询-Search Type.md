# ES查询-Search Type

> ES查询是有个`search_type`参数可以设置，之前一直没有留意。那么这个参数有什么用呢？
> 
> 本文ES版本为`7.1.1`，不同版本支持的Search Type不同，实际使用时请根据对应版本来选择。

## 分布式环境下搜索的问题

在单机环境下做搜索只需要考虑本机的数据即可，但是在分布式环境下做搜索可能就没有那么简单了。ES中存在数据分片的概念，也就是shard。数据被分散存储在不同的shard中，而一个shard就相当于一个Lucene实例。那么这种情况ES该如何搜索呢？简单的说分为两步：

- 将查询请求发送到各节点的分片中，在每个分片中进行计算。这个过程类似于MapReduce中的map过程，在ES中称为`Scatter`。

- 接着将上一步的结果汇集到一个节点中，再整体就行一次计算，得到最终的查询结果。这个过程类似于MapReduce中的Reduce过程，在ES中称为`Gather`。

## query_and_fetch和query_then_fetch

对于像求和之类的查询问题基本上和单机环境没啥区别，但是对于像TopN之类的问题则会比较麻烦。例如想在需要算出订单金额排名前十的订单，那么有两种方案来实现。

- 获取每个shard的订单金额最多的前10个订单数据，然后将所有shard中前10的订单数据汇集到一个节点，然后在该节点上对数据做排序，然后再获取订单金额前10的订单。例如现在有3个shard，每个shard获取前10的订单，然后汇总一共30条数据，最后从这30条数据中获取10条。

- 而另外一种处理方式和前面的方式稍微不同。首先和前面的一样都是找出每个shard中订单金额前10的订单数据，然后将订单数据的id和金额（因为这里是按金额排序）信息汇总到同一个节点。然后同样做排序选出前10的数据，最后再去数据对应的节点获取整条数据信息。

上面的两种方法，第一种对应的就是`search_type`中的`query_and_fetch`,而第二种对应的就是`query_then_fetch`。

对于`query_and_fetch`而言，其好处是只需要访问一次shard就能获取最后的结果，缺点就是I/O随着shard的增加而增加。而对于`query_then_fetch`它的好处是能减少I/O的开销，但是缺点是需要访问实际shard两次才能获取到结果。

> 在笔者使用的`7.1.1`版本中，`query_and_fetch`已被移除不支持使用了。该版本默认为`query_then_fetch`。

## dfs_query_then_fetch和query_then_fetch

这两个的区别跟搜索引擎有关，在对特定的shard做查询时，其评分结果只与当前的shard有关，并不会考虑到其他shard。那么根据之前的方式来处理，那么结果与实际结果则会存在偏差。

文档被路由到不同的shard，每个shard的文档数量、词频等会出现不同。这些因素会影响搜索结果中文档的打分。例如在全市举行了一个考试，考试的试题不同，最后需要找出全市前100名，如果从每个学校获取前100名学生，然后再次做排名取100个，这个结果很明显不是特别的合理。

而`query_then_fetch`就是这种方式，而`dfs_query_fetch`大体上也类似，不同的点在于多了一个初始化计算全局词频的这么个步骤，在一定程度上可以更加精确的控制打分。但是这种方式在性能上也是最差的。

## 小结

对于大多数情况下，使用默认的`query_then_fetch`不会有问题。但是对于某些极端情况下，我们可以通过修改`search type`来优化我们的查询。具体情况还是需要根据业务实际情况来具体分析。
