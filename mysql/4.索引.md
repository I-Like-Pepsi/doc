# 索引

## 常见的索引模型

### 哈希表

哈希把值放在数组中，用哈希函数把key换算成数组中的一个索引位置，把值放在数组指定的索引位置中。如果出现多个不同的key算出的数组索引位置相同的情况，则在数组索引位置拉出一个链表存储值。

哈希索引适合只有等值查询的场景，所以哈希索引做区间查询时的速度非常慢。

### 有序数组

有序数组在等值查询和范围查询的场景中非常优秀。查询时通过二分法能找很快的找到目标值，在做范围查询时，找到起始范围的值，然后向后遍历直到不满足范围的结束值时结束即可。

但是对于更新数据时非常麻烦，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以有序数组索引只适用于静态存储引擎。

### 二叉树

二叉树的特点是左子树所有节点小于父节点，右子树所有节点的值大于父节点。但是极端情况下，二叉树可能退化成链表，所以需要平衡二叉树。

在一个100万节点的平衡二叉树中，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代随机读取一个数据块需要10ms。对于一个一百万行的表，使用平衡二叉树需要200ms，查询效率并不会有多快。

### N叉树

为了尽量少的读取磁盘，就必须减少访问数据块的次数。所以使用N叉树来降低树的高度。在InnoDB中这个N差不多是1200，Mysql默认数据页的大小为16K，一个整数（bigint）字段的索引的长度为8B，另外每个索引还需要6B存储指针，所以计算的N=16*1024/14大约为1200个。当树高为4时，就能存储1200的3次方的数据了。

## InnoDB的索引模型

InnoDB中表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，数据都是存储在B+树中。

在Mysql中每个索引对应了一颗独立的B+树。

根据索引类型分为主键索引和非主键索引，主键索引的叶子节点存储的是整行数据，在InnoDB中，主键索引也被称为聚族索引。而非主键索引的叶子节点存储了索引的值和主键，非主键索引也被称为二级索引。

例如现在有两条sql语句如下：

```sql
select * from t where id = 1;
select * from t where name = 'mac';
```

假设id为主键，对name字段做了索引。那么基于主键索引和二级索引分别做查询有什么不同呢？

- 对于语句1即通过主键索引查询数据，则只需要搜索ID这棵索引树即可完成查找。

- 对于语句2即二级索引查询数据，需要先搜索name这棵索引树找到对应的节点，然后通过节点中的ID，然后再通过ID查找ID索引树再找到这条完整的数据，而这个过程就称作是回表。

## 索引维护

B+树为了维护索引的有序性，在插入新值的时候需要做必要维护。例如存在ID为100,200,300,400的数据，如果要插入ID为500的数据则只需要在ID为400的数据后面插入即可。如果此时要插入ID为101的数据，则需要逻辑上挪动后面的数据，空出位置插入。

更糟糕的情况是，原本的数据页已经满了，根据B+树的算法，这个时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂。除了性能上的损失外，还影响了数据页的利用率。

当相邻的两个数据页由于删除了数据利用率很低之后，会将数据页做合并处理，这个过程可以认为是分裂的逆过程。

## 索引覆盖

例如现在存在一个用户表t_user，里面存在三个字段id、age、name三个字段，并且我们为age字段创建了一个索引。现在的查询语句如下：

```sql
select name, age from t_user where age = 18;
```

针对这个查询mysql首先根据age=18在索引为age的索引树中查找，找到对应的数据后再根据结果集中的id回表去主键索引中查找。

所谓的索引覆盖，我们可以将age索引修改为age和name的联合索引，这样在age和name的索引中找到结果后就可以直接返回结果集，而省略了回表的操作从而提高查询效率。

## 最左匹配原则

还是上面那个例子，我们建立的索引顺序是age然后才是name，此时如下查询是无法使用到索引的。

```sql
select name, age from t_user where name = '小明'
```

因为在索引树中它的顺序是按照age+name的顺序排列的，对于age的顺序是不变的，但是name不是有序的，所以索引是不会生效的。

## 索引下推

还是上面的例子，已知建立了根据name和age建立了一个联合索引，现在的查询如下：

```sql
select * from t_user where name like '张%' and age = 18;
```

根据前面的最左匹配原则我们知道了```name like '%张'```能使用到索引，但是age无法使用到索引。之后则需要通过回表找到原记录，再过滤出```age=18```这个条件的记录。 但是在5.6之后，mysql引入了索引下推的概念。对于上面的查询，前面还是一样通过索引找到对应的结果集，然后再根据索引中的age再进一步过滤结果集，最后再回表去找到对应的记录返回。

相比于没有索引下推的情况而言，索引下推能较少回表的次数。
