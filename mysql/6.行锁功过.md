# 行锁功过

Mysql中的行锁是由各个引擎自己实现的。但并不是所有引擎都支持行锁。比如MyISAM就不支持行锁。

## 两阶段锁

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到整个事务结束是才释放。这个就是两阶段锁协议。

根据两阶段锁协议如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发的锁尽量往后放。

## 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

解决死锁有两种策略：

- 直接进入等待，知道超时。这个超时时间可以通过参数```innodb_lock_wait_timeout```来设置。

- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数```innodb_deadlock_detect```设置为on，表示开启这个逻辑。

死锁等待超时时间默认为50s，对于服务来说，这个时间往往无法接受。但是我们又不能设置的太小，设置太小会出现过多的误伤。

正常情况下我们采取第二种策略死锁检测。主动死锁检测在发生死锁的时候能够快速发现并进行处理，但是它也有额外的负担。每当一个事务被锁住的时候，就要看看它依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

如果有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级。最终检测结果是没有死锁，但是这期间要消耗大量的CPU资源，但是每秒却无法执行几个事务。
